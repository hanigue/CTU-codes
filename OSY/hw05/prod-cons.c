// 1. 11. by Matous Dzivjak <dzivjak@matous.me>
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <semaphore.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <stdbool.h>

// Producent and consument methods
void *prod(void *arg);
void *cons(void *arg);

// Input struct to store in linked list
typedef struct input_t {
  char *text;
  int num;
  struct input_t *next;
} input_t;

// Linked list struct
typedef struct linked_list_t {
  input_t* start;
  input_t* end;
  int len;
} linked_list_t;

// Globals
sem_t semaphore;
pthread_mutex_t locker;
bool end = false;
linked_list_t* llist;
bool failed = false;

// Alloc new linked list
linked_list_t* new_llist(){
  linked_list_t* llist = (linked_list_t*)malloc(sizeof(linked_list_t));
  llist->len = 0;
  llist->start = NULL;
  llist->end = NULL;
  return llist;
}

// Is the list empty?
bool is_empty(linked_list_t * llist){
  pthread_mutex_lock(&locker);
  bool result = llist->len == 0;
  pthread_mutex_unlock(&locker);
  return result;
}

// Clear all remaining elements in the list
void clear(linked_list_t * llist){
  if(is_empty(llist)) return;
  pthread_mutex_lock(&locker);
  input_t* curr = llist->start;
  while(curr != NULL){
    input_t* tmp = curr->next;
    free(curr);
    curr = tmp;
  }
  pthread_mutex_unlock(&locker);
}

// Push element on the end of the linked list
void push(linked_list_t * llist, input_t * elem) {
  pthread_mutex_lock(&locker);
  if(llist->len == 0){
    llist->start = elem;
    llist->end = elem;
    llist->len++;
  } else {
    llist->end->next = elem;
    llist->end = elem;
    llist->len++;
  }
  pthread_mutex_unlock(&locker);
}

// Pop element from the start of the list
input_t* pop(linked_list_t * llist){
  pthread_mutex_lock(&locker);
  if(llist->len == 0) return NULL;
  input_t* tmp = llist->start;
  llist->start = tmp->next;
  llist->len--;
  pthread_mutex_unlock(&locker);
  return tmp;
}

int main(int argc, char ** argv){
  // Handle the arguments
  int N = 1;
  if(argc == 2){
    N = atoi(argv[1]);
    if (N > sysconf(_SC_NPROCESSORS_ONLN)){
      fprintf(stderr, "Can't have more consumers than CPUs!\n");
      exit(1);
    }
  }
  else if (argc > 2) {
    fprintf(stderr, "Invalid arguments, expected one argument max!\n");
    exit(1);
  }

  // Init variables
  sem_init(&semaphore, 0, 0); // semaphore
  llist = new_llist(); // linked list
  if ( llist == NULL ) exit(1);
  pthread_t thid; // producer
  pthread_t *thids = (pthread_t*)malloc(N*sizeof(pthread_t)); // consumer
  if ( thids == NULL ) exit(1);
  void *ret; // return value

  // Create producer
  if(pthread_create(&thid, NULL, prod, "prod")){
    exit(1);
  }

  // Create consumers
  int finished_at = -1;
  for(int i = 0; i < N; i++){
    int *arg = malloc(sizeof(*arg));
    if ( arg == NULL ) exit(1);
    *arg = i+1;
    if(pthread_create(&thids[i], NULL, cons, arg)){
      finished_at = i;
      perror("creating consumer err");
      break;
    }
  }

  // Finish
  if(pthread_join(thid, &ret) != 0) {
    sem_destroy(&semaphore);
    free(ret);
    free(thids);
    clear(llist);
    free(llist);
    exit(1);
  }
  if ( ret == NULL ) exit(1);
  int x = *((int *) ret);
  free(ret);

  end = true;
  for(int i = 0; i < N; i++){
    if(finished_at != -1 && i >= finished_at) break;
    if(pthread_join(thids[i], &ret) != 0) {
      perror("consumer exited with status bad");
    }
  }

  // Free everything
  sem_destroy(&semaphore);
  free(thids);
  clear(llist);
  free(llist);
  if (x != 0){
    exit(1);
  }
  exit(0);
}

// Producets
// Reads <X> <Y> from stdin, where X is number and Y is string
// X and Y might but don't have to be separeted by whitespace
void *prod(void *arg){
  int *ret = malloc(sizeof(*ret));
  if ( ret == NULL ) exit(1);
  *ret = 0;
  input_t *i = (input_t*)malloc(sizeof(input_t));
  if(i == NULL) {
    *ret = 1;
    return ret;
  }
  while((*ret = scanf("%u %ms", &(i->num), &(i->text))) != EOF){
    if (*ret < 1){
      free(i);
      *ret = 1;
      return ret;
    }
    push(llist, i);
    sem_post(&semaphore);
    i = (input_t*)malloc(sizeof(input_t));
    if(i == NULL) {
      *ret = 1;
      return ret;
    }
  }
  free(i);
  *ret = 0;
  return ret;
}

// Consumer consumes from linked list generated by producer
void *cons(void *arg){
  // Parse consumers number
  if(arg == NULL) return (void*) 0;
  int me = *((int *) arg);
  free(arg);

  struct timespec ts; // for timed waiting

  while(!(is_empty(llist) && end) && !failed){
    if(clock_gettime(CLOCK_REALTIME, &ts) == -1) return (void*) 1;
    ts.tv_nsec += 1000*1000*10;
    int ret = sem_timedwait(&semaphore, &ts);

    // timed out
    if(ret == -1) continue;

    input_t *x = pop(llist);
    if (x != NULL){
      int l = 8 + 10 + x->num*(strlen(x->text)+1);
      char *s = (char*)malloc(l);
      // Alloc failed
      if (s == NULL) {
        free(x);
        failed = true;
        return (void*) 1;
      }
      // Prepare to print
      int idx = sprintf(s, "Thread %d:", me);
      if(idx < 0){
        free(x);
        perror("sprintf err");
        return (void*) 1;
      }
      for(int i = 0; i < x->num; i++){
        s[idx++]= ' ';
        for(int k = 0; k < strlen(x->text); k++){
          s[idx++] = x->text[k];
        }
      }
      s[idx++] = '\0';
      // Print
      fprintf(stdout, "%s\n", s);
      // Free
      free(s);
      free(x->text);
      free(x);
    }
  }
  return (void*) 0;
}
